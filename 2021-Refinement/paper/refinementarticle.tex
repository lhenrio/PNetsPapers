\documentclass[runningheads]{llncs}

\usepackage{tikz}

\usepackage{amsmath,amssymb,mathabx}
%\usepackage{amsthm}
%\usepackage{unicode-math}
\usepackage{tikz}
\usetikzlibrary{external}
\usepackage{hyperref}
\usepackage{nccrules}
\AtBeginDocument{\renewcommand\setminus{\smallsetminus}}

\newcommand{\symb}[1]{\makebox{\it #1}}
\input{common.tex}
\input{preamble.tex}
\input{tikzmacros.tex}


\begin{document}
%
\title{Refinements for open automata}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{
Rabéa\inst{1}\orcidID{1111-2222-3333-4444} \and
Quentin\inst{1,2}\orcidID{1111-2222-3333-4444} \and
Ludo\inst{2}\orcidID{0000-1111-2222-3333} \and
Eric\inst{3}\orcidID{2222--3333-4444-5555}}
%
\authorrunning{Rab\'ea Ameur-Boulifa et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{blabla
\email{lncs@fff}\\
\url{http://www.springer.com/gp/computer-science/lncs} \and
blibli\\
\email{\{abc,def\}@fff}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
\TODO{ The abstract should briefly summarize the contents of the paper in 150--250 words.}

Establishing equivalences and refinement relations between programs is an important mean for 
verifying the correctness of programs, by formally proving the relation between a specification and an implementation, 
proving that two implementation are equivalent, or justifying optimisations and transformations, by establishing that the
behaviors of a modified program simulate those of to the source one.

In this article, we discuss a notion of refinement between so-called "open automata", which are symbolic
behavioral models for communicating systems. Open automata may have "holes" modeling elements of their
context, and can be composed by instanciation of the holes. This allows for a compositional approach for
verification of their behavior, essential to address proofs about large realistic systems.

We define several variants of refinement between systems including either equal or different sets of holes, and 
show under which conditions these refinements are preserved by composition of open automata. We also discuss
the relations between these refinements and the existence of deadlocks.
We illustrate these notions on several simple use-cases.


\keywords{Labelled transition systems  \and Refinement \and Composition.}
\end{abstract}
%
%
%
\section{Introduction}
\TODO{1.5 pages}



Contributions:

We first: introduce open automata (NOT NEW), their composition, and the deadlock-free composition.

Then we define a refinement relation for open automata that has the following characteristics:

- good behaviour wrt composition

- refinement does not introduce deadlock

- a first relation that focuses on the automaton part and a second that deals partially with open behaviour

we will see that having at the same time composition and transitivity also raises challenges; we introduce a relation that addresses this challenge.


\section{Related Work}
\label{sec:sota}

\TODO{1 page}


The notion of refinement aims of capturing the relation between  a specification and an implementation of the same component. It is usually defined as trace inclusion or simulation \cite{Milner:1980, Kouchnarenko:2007}; this ensures that all behaviours of the implementation must be also behaviours of the specification. This definition, which is based on systems whose behaviour is fully defined, is not well-suited for open systems,  as it requires to reason also about unspecified behaviours.

There are some works that have focused on  the refinement of open systems. Defining refinement of open systems as trace inclusion  is  addressed  as a notion of subtyping in type theory 
\cite{GayH:2005,BravettiZ:2021}. Such refinement is  instead based  on interface-oriented approach, it allows the expression more internal choices and less external choices. The refinement of open systems is also defined in terms of  alternating simulation \cite{Alur:1998,deAlfaro:2021}, which deals with game-based models.
Alternating simulation that is originating from the game theory \cite{deAlfaro:2003} allows  the study of relation between individual components by viewing them as alternating transition systems. In particular,  a refinement of game-based automata expresses that the refined component can offer more services (input actions) and fewer service demands (output actions). However, the composition of such automata may
lead to illegal states, where one automaton issues an output that is not acceptable as input in the other one. The theory of alternating simulation provides an optimistic approach to compute compatibility between automata based on the fact that each automaton expects the other to provide  legal inputs, i.e, two components can be composed if there is an environment where they can work together. As we shall see in this paper, 
our approach to design refinement  has some commonalities with that of the above mentioned \cite{deAlfaro:2021}: both are process-oriented approach even if they are not based on the same notion of simulation and they are based on optimistic approach to composition. 
For the composability, we shall see that we use the notion of comparability of holes (similar to the notion of compatibility), which is explicitly encompassed in the definition of composition.

 



Previous work on open automata focused on equivalence relations compatible with composition.
In an article by Hou, Zechen and Madelaine \cite{10.1145/3372884.3373161}, a computable bisimulation is introduced and proved equivalent to the previous bisimulation already introduced.
In a more recent work by Ameur-Boulifa, Henrio and Madelaine \cite{2007.10770}, a weak version of the bisimulation on open automata is introduced.
These works differ from ours because the relation introduced in this report is a refinement relation in the form of a simulation and not a bisimulation.
Also we do not have results as strong as computability neither a weak version able to tackle silent actions.

\TODO{Some related work on other models than open automata introduce refinement relations.
In a chapter by Bellegarde, Julliand and Kouchnarenko \cite{10.1007/3-540-46428-X_19}, a simulation relation on transition systems is introduced.
This simulation encompass action refinement, is able to deal with silent actions and is compatible with parallel composition.
Here the refinement relation does not consider action refinement as valid but it should be done in future work.
Also they check how LTL properties are preserved or combined using their refinement which we do not do.
However their model is less expressive: the transition system model is less expressive than open automata and the parallel composition is less expressive than composition on open automata.
In a later report by Kouchnarenko and Lanoix \cite{10.1007/978-3-540-70881-0_26}, the refinement relation they introduce is on LTS (labelled transition systems).
Their relation additionally prevents deadlock and livelocks.
The composition is also extended to synchronised composition which is more expressive.
In our work we also deal with deadlocks but not with livelocks since the latter arise only with silent actions.
This work is closer than the previous one to what we do here, still open automata are more expressive than LTS and composition is more general than synchronised composition.}

A refinement relation on models nearer to open automata is introduced in an article by Zhang, Meng and Lo \cite{Zhang2014}.
In their article they work with transition systems with variable which makes the state space potentially infinite.
This aspect is also present in open automata.
They show how invariants, a notion near to our reachability predicates, are composed.
By relation on these invariants they introduce several refinement relations.
We could have done something similar for non-locking composition reachability predicates which are introduced in Section \ref{sec:proofelts}.

On the deadlock prevention aspect, an article by Dihego, Sampaio and Oliveira \cite{DIHEGO2020110598} present a refinement relation on process algebra (translated to LTS).
This refinement relation is a special case of inheritance and prevents the introduction of deadlocks.
Their refinement and inheritance are quite the opposite of our refinement in terms of new behaviours.
They have channels, interfaces, inputs and outputs, which in the open automata model can be compared to action labels, holes and action data for both inputs and outputs.
They have a rich composition as open automata but the introduction of deadlock is already prevented by a well chosen set of composing operations.
Also their composition is slightly different than the one on open automata because they can cause loops by linking two channels of the same process, where in open automata the composition makes an oriented tree.
In their model there is an explicit deadlock and a successful termination where in open automata there are no explicit termination.
We define a deadlock as a configuration without possible transition and assume what is a deadlock when comparing the open automata.
To define their refinement and inheritance relation they use trace and failure semantics, which are weaker than (bi)simulations \cite{10.5555/640428.640430} and could break with open automata composition.


\section{Background: Open Automata and their Composition}\label{sec:background}
\TODO{3.5 pages}

This section presents the notations we used and the principles of automata. Except for minor changes in the notations, the only new contribution of this section is the definition of a composition operator for open automata.
%
%Notations will be defined with the operator \(\defnotation\) and names are given with the operator \(\defobject\) as follows:
%\begin{align*}
%	\mathit{notation\_with\_variables} & \defnotation \mathit{notated\_object\_using\_the\_variables} \\
%	\mathit{name} & \defobject \mathit{fully\_defined\_mathematical\_object}
%\end{align*}

%Throughout this paper, tuples will be noted differently depending on what they represent.
%This helps distinguishing the manipulated objects.
%Every such notation will be introduced in the definition of the object.

Families of values, or equivalently maps will be noted \(\mset{i \mapsto x_i}{i \in I}\), \(\mset{i \gets x_i}{i \in I}\) or \(x_i^{i \in I}\). % TODO: introduire le fait que \exists c_j^{j \in J} défini J et {j \mapsto c_j}
%For instance \(\mpar{ax}^{x \in \setR}\) represents a scaling function, \(c^{i \in I}\) is a constant function over \(I\).
%They will be used depending on what is more convenient.
%For instance \(\mbrc{\alpha \mapsto 1, \beta \mapsto 2, \gamma \mapsto 3}\) has no simple generating expression and is better represented with the finite version of first notation.
The disjoint union on set is noted \(\uplus\)\footnote{\(\uplus\) notation either supposes that the sets are disjoint or rename conflicting objects depending on the context}. Disjoint union is also used on maps.
%There are several ways of ensuring a union is disjoint, we will indifferently either suppose sets are disjoint or rename conflicting object (useful for variables).
%The disjoint union of two maps \(\varphi: I \to X\) and \(\psi: J \to Y\) with \(I \cap J = \emptyset\) is noted \(\varphi \uplus \psi\) and has the following signature \(I \uplus J \to X \cup Y\).
In a formula, a quantifier followed by a finite set will be used as a shorthand for the quantification on every variable in the set:
\(\forall \mbrc{a_1, \dots, a_n}, \exists \mbrc{b_1, \dots, b_m}, P\) means \(\forall a_1, \dots, \forall a_n, \exists b_1, \dots, \exists b_m, P\).

%\begin{definition}[Expression algebra, Action algebra, Formulas, Terms]
An expression algebra \(E\) is the disjoint union  of  terms,  actions, and  formulas
\( E=\terms \uplus \actions \uplus \formulas\) .
\(\terms\) and \(\actions\) are term algebras.
The formulas \(\formulas\) contain at least first order formulas and equality\footnote{Equality does not need to be only syntactic.} over \(\terms\) and \(\actions\). 
%\end{definition}

 \(\fvars{e}\) is the set of variables in \(e \in E\) that are not bound by any binder. An expression is closed if \(\fvars{e}=\emptyset\).
The set \(\values\) denote values which is a subset of closed terms. \(\rformulas[V]\) is the set of formulas $f$ that only use variables in $V$, i.e. the formulas such that  \(\fvars{f}\subseteq V\).

The substitution in \(e \in E\) of \(x \in \fvars{e}\) by \(t \in \terms\), is denoted \(e\subst{t}{x}\), and its generalisation to the parallel substitution of variables in \(V\) by \(\psi: V \to \terms\) is denoted \(e\psubst{\psi}\).


 We suppose given a decidable satisfiability relation on formulas, \({\vdash} f\) is the satisfiability over closed formulas.
% In practice one of our objective is to be able to use a SMT solver to reason automatically on the properties of open automata, in this case
%\(\vdash\) can hence be interpreted as an indicator of what is given to the SMT; it separates the external logic and the logic on \(\formulas\).
We will  use two satisfiability relations:
\begin{itemize}
\item The satisfiability of a formula \(f \in \formulas\) under some valuation \(\sigma: V \to \values\) is defined as follows:
\( \sigma \vdash f ::= \vdash \exists \fvars{f\psubst{\sigma}}, f\psubst{\sigma} \)
\item The satisfiability of a formula \(f \in \formulas\) with some variable set \(V\) as context is defined as follows:
\( V \vdash f ::=  \vdash \forall V, \exists\mpar{\fvars{f} \setminus V}, f \)
\end{itemize}

%For instance a formula with quantifiers on variables might not be provable even if it is true for all values of these variables.

\subsection{Open Automata}\label{sec:def}
 Open automata (abbreviated OA) are labelled transition systems with variables  that can be used to compose other automata: they are made of transitions that are dependent of the actions of ``holes'', a composition operation consists in filling a hole with another automaton to obtain a more complete automaton. The variables makes the OA symbolic, and the holes allow for a partial definition of the behaviour.

\begin{definition}[Open transition, Open automaton (OA)]
An \emph{open automaton} is a tuple \(\OAg\) with \(S\) the set of states, \(s_0 \in S\) the initial state, \(V\) the finite set of variable names, \(\sigma_0: V' \to \values\) the initial valuation of variables where \(V' \subseteq V\), \(J\) the set of hole names and \(T\) the set of open transitions.

An \emph{open transition} is a tuple \nmm{\OTg} with \(s, s' \in S\) the source and target states, \(\alpha \in \actions\) the produced action, \(J' \subseteq J\) the holes involved in the transition, \(\beta_j \in \actions\) the actions of the holes, \(g \in \formulas\) the guard and \(\psi: V \to \terms\) the variable assignments.
\end{definition}

The following terminology will be used to reason on open automata
\begin{definition}[Configuration, instantiated transition]
A pair of a state and a valuation is called a \emph{configuration}.
An \emph{instantiated transition} of an automaton \(\OAg\) is a transition  \(t\psi\) where $t\in T$ and $\psi$ is a  well-formed substitution of the unbound variables of $t$  minus the automaton variables $V$.
\end{definition}



\TODO{useful or not?}
\begin{definition}[Guard, Out-transition, Transition variables]
Let \(V\) be the variable names of the considered automaton, \(T\) its transitions and \(r\) one of its states.
\(\fOT[T]{r} \in T\) are called the out-transitions of the state \(r\).
\(\fIT[T]{r} \in T\) are called the in-transitions of the state \(r\).
When the transition set is clear from the context, it will be omitted.
The local variables of a transition \(\fvars{t}\) are all variables appearing in transition \(t\) except the global variables of the automaton.
\begin{align*}
	\fOT[T]{r} & ::= \mset{\OTg \in T}{s = r} &
	\fIT[T]{r} & ::= \mset{\OTg \in T}{s' = r} \\
\end{align*}
\vspace{-1cm}
\begin{gather*}
	\fguard{\OTg} ::= g \\
	\fvars{\OTg} ::= \mpar{\fvars{\alpha} \cup \fvars{g} \cup \bigcup_{j \in J'} \fvars{\beta_j} \cup \bigcup_{v \in V} \fvars{\psi\mpar{v}}} \setminus V
\end{gather*}
\end{definition}


\paragraph{Open automaton composition}

Open automata are partially specified automata, that partiality comes mostly from the holes.
A hole is an interface in which we can plug an open automaton.
The plugging operation is called composition.
The composition of open automata was already implicitly defined by the means of composition on pNets in previous work \cite{henrio:01299562} but never completely formalised on open automata.
The definition of composition below is a direct translation of what happens with pNets composition without the need of introducing pNets.
\begin{definition}[Composition of open automata]
The composition of \(A_c = \OAg[c]\) in the hole \(k \in J_p\) of \(A_p = \OAg[p]\) is the OA defined as follows:
\[A_p\subst{A_c}{k} ::=  \OA{S_p \times S_c}{\mpar{s_{0p}, s_{0c}}}{V_p \uplus V_c}{\sigma_{0p} \uplus \sigma_{0c}}{J_c \uplus J_p \setminus \mbrc{k}}{T} \] \text{with }

\begin{align*}
T=& \mset{\OT{\mpar{s_p, s_c}}{\mpar{s'_p, s'_c}}{\alpha_p}{\beta_j^{j \in J'_c \uplus J'_p}}{g_p \wedge g_c \wedge \alpha_c = \beta_k}{\psi_p \uplus \psi_c}}{ \OT{s_p}{s'_p}{\alpha_p}{\beta_j^{j \in J'_p \uplus \mbrc{k} }}{g_p}{\psi_p} \in T_p, \OTx{c}{}{}{c} \in T_c} \\
	& \cup \mset{\OT{\mpar{s_p, s_c}}{\mpar{s'_p, s_c}}{\alpha_p}{\beta_j^{j \in J'_p}}{g_p}{\psi_p}}{\OTx{p}{}{}{p} \in T_p, k \notin J'_p, s_c \in S_c}
\end{align*}
\end{definition}
The first OA decides when the second can evolve by involving its hole in a transition:
The action emitted when \(A_c\) makes a transition is synchronised with the action of the hole \(k\) in transitions of \(A_p\) .


\paragraph{A bisimulation for open automata}

TODO OR NOT?

\subsection{Example}

As an example, the traffic light system  that controls  
 traffic at the intersection of a busy highway. The open automaton  
modeling this system  is illustrated in  Figure \ref{fig:tls}. This automaton has three states  remembering which coloured light
is on (Red, Yellow or Green). It includes two holes: a controller ($\symb{ctl}$) and a counter ($\symb{cnt}$)  depicting together the behaviour of the timer. The color switches when the counter and the controller component agree that the time is over. The new time limit can be set by the counter component and the exposed action to the environment is an unobservable  action $\tau$.

The open automata shown in Figure  \ref{fig:ctlandcnt} models  the timer. On the left, the controller component designed to be connected in the hole $\symb{ctl}$.  Its role is to decide the duration before switching the lights. 
We control the time interval for each light by setting them by prior knowledge:  17s for the first duration, 3s for the second, and 20s for the third. On the right, the tick counter component designed to be connected in the hole $\symb{cnt}$.                                                                                                                                     




In Figure \ref{fig:tlf} we present the composition of the three automata. Each state of the result of the composition consists  of  a state of traffic light system together with a state of controller component and one of counter component. The composed automaton  takes over  the same steps as the traffic light automaton but it also includes new steps,  indicting the change of states for the setting of timer. Its $\tau$ transitions involve both the traffic light automaton and the hole  automata, they correspond to  a joint step of  sending time thresholds of the controller, the time setting of the counter. For instance, the  $\tau$  transition starting from \(R1S\), it is obtained by composition of both 
\nmm{\OT{R}{R}{\tau}{\mbrc{cnt \mapsto \act{set}\mpar{x}, ctl \mapsto \theta\mpar{x}}}{\top}{\mbrc{}}}, \nmm{\OT{1}{2}{\theta\mpar{17}}{\mbrc{}}{\top}{\mbrc{}}} and   \nmm{\OT{S}{C}{\act{set}\mpar{x}}{\mbrc{}}{\top}{\mbrc{t \gets x, c \gets 0}}}. \\ 
However, the joint composition of transitions  \nmm{\OT{R}{R}{\tau}{\mbrc{cnt \mapsto \act{set}\mpar{x}, ctl \mapsto \theta\mpar{x}}}{\top}{\mbrc{}}}, \nmm{\OT{2}{3}{\delta\mpar{x}}{\mbrc{}}{\top}{\mbrc{}}} and 
\nmm{\OT{C}{C}{\act{tick}}{\mbrc{}}{c < t}{\mbrc{c \gets c + 1}}} is not agreed because it would produce a transition whose guard is not satisfiable. It will produce the following transition: \nmm{\OT{R2C}{R3C}{\tau}{\mbrc{}}{\top \wedge \top \wedge c < t \wedge \act{set}\mpar{x} = \act{tick} \wedge \theta\mpar{x} = \delta\mpar{x}}{\mbrc{c \gets c + 1}}} which requires to be triggered  the equality of completely different actions. 








\begin{figure}
\centering
\input{Traffic_Lights_Spec.tex}
\caption{The specification of a Traffic Light system}
\label{fig:tls}
\end{figure}


\begin{figure}
%\centering
\input{Traffic_Lights_Controller.tex}
\input{Traffic_Lights_Register.tex}
\caption{(a) An example of controller component ~~  (b) An example of counter component}
\label{fig:ctlandcnt}
\end{figure}

\begin{figure}
\centering
\input{Traffic_Lights_Interm.tex}
\caption{The incomplete Specification Traffic Lights system}
\label{fig:tlf}
\end{figure}



\begin{figure}
\centering
\input{Traffic_Lights_Full.tex}
\caption{The full Traffic Lights system}
\label{fig:tlf}
\end{figure}


\section{A First Refinement Relation}\label{sec:refinement}

Similarly to FH-bisimulation~\cite{fhbisim} we are interested here in finding relations between states of to open automata that contain variables and holes. However here we want to build a refinement relation that is a simulation but also guarantees that no deadlock is introduced.
Our objective is to characterize when a relation between two states of two open automata have the desired property. Such a relation has the following signature: \( S_1 \times S_2 \to \rformulas[V_1 \uplus V_2]\).
We first define when a relations is deadlock reducing, before characterising a first simple refinement relation only valid to compare automata with identical holes.

\subsection{Deadlock Reduction, Reachability, and Composition}

\begin{definition}[Deadlock reduction]\label{def:dpwd}\\
Let \(\OAg[1]\) and \(\OAg[2]\) be two OAs.
A relation on OA configurations \(R: S_1 \times S_2 \to \rformulas[V_1 \uplus V_2]\) is deadlock reducing if  it satisfies the following:
\begin{multline*}
 \forall \mpar{s_1, s_2} \in S_1 \times S_2,\\ V_1 \uplus V_2 \uplus \biguplus_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \vdash \left(R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1} \right)
\end{multline*}
\end{definition}

One important aspect to notice is that in this definition, because of the symbolic nature of OAs and their structure, the fact that a guard is true is sufficient to reason on the possible paths. This slightly simplifies the definition and makes the characterisation of transition that can be triggered more symbolic. An equivalent  definition of deadlock reduction can be expressed: it states that if there is a transition that can be triggered in the first automaton, then there is a transition from the related state in the second automaton that can be triggered. This second definition is more complex, in particular because of the multiple quantifiers over transitions and automaton state.

Unfortunately, in the general case, this property is not much useful in general because it conflicts with the possibility to compose automata: The composition operator can itself introduce a deadlock.
A way to solve the conflict between deadlock reduction and the properties involving composition is to only consider a composition that do not introduce deadlocks.

Before characterising a composition which does not introduce deadlocks we need to be able to tell which states are reachable.
\begin{definition}[Reachability]
For any open automata \(A = \OAg\), a reachability predicate \(\reach{A}: S \to \rformulas[V]\) is any predicate on states that is preserved across transitions, and valid on initial state:
\[\sigma_0 \vdash \reach{A}\mpar{s_0}\quad\land\quad\forall t = \OTg \in T, \fvars{t} \vdash \left(\reach{A}\mpar{s} \wedge g \implies \reach{A}\mpar{s'}\psubst{\psi}\right)\]
\end{definition}
Reachability takes into account all paths, and potentially over-approximate the reachable configurations and must be representable as a formula.
% LUDO HERE
\begin{definition}[Non-locking composition]
Let \(A_i = \OAg[i], 0 \leq i \leq n\).
The composition \(A = A_0\mdbrk{j_i \mapsto A_i \middle| 1 \leq i \leq n}\) 
 is a non-locking composition if if \(A \) has a reachability predicate satisfying the following.
From reachable configurations, if there was a possible transition in \(A_0\) then there is a possible transition in \(A\):
\[ \forall s = \mpar{s_0, s'} \in S, V \uplus \biguplus_\subbox{t_0 \in \fOT{s_0}} \fvars{t_0} \vdash \left(\reach{A}\mpar{s} \wedge \bigvee_\subbox{t_0 \in \fOT{s_0}} \fguard{t_0} \implies \bigvee_\subbox{t \in \fOT{s}} \fguard{t} \right)\]
\end{definition}
Again we use guards as a characteristics that the transition occurs.



\subsection{Refinement Relations for automata with the same holes}

We define here simulation between labelled transition systems to Hole-equal simulation  between  open automata that have exactly the same holes.
\begin{definition}[Hole-equal simulation]
Consider two OAs \(\OAg[1]\) and \(\OAg[2]\) with  \(J_1 = J_2\), the relation on configurations \(R: S_1 \times S_2 \to \rformulas[V_1 \uplus V_2]\) is a hole-\(\symb{equal}\) simulation from $S_1$ to $S_2$ if the following conditions hold: 
\item[(1)] \(\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}}\)
\item[(2)] \(\forall \mpar{s_1, s_2} \in S_1 \times S_2,\)\vspace{-8pt}
\noindent\begin{multline*}
\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} t_1 = \OTx{1}{}{1}{1} \in \fOT{s_1}, \bigsymb{\exists} \mpar{t_{2x} = \OTx{2}{x}{2x}{2x} \in \fOT{s_2}}^{x \in X}, \\
		\quad \mpar{\forall x \in X, J'_{2x}= J'_1} \\[-2pt]
		\nwedge V_1 \uplus V_2 \uplus \fvars{t_1} \vdash \left( R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_{2x}} \beta_{1j} = \beta_{2xj} \\[12pt]
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}}\right)
	\end{array} 
%\\
%	\wedge \mpar{V_1 \uplus V_2 \uplus \biguplus_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}}
\end{multline*}
\item[(3)] $R$ is deadlock reducing.
\end{definition}


Note in this definition, instead of matching an instantiated transition of the first automata to another instantiated transition of the second, it matches an open transition $t_1$ to a family of covering open transitions $t_{2x}^{x\in X}$. %Note also the second part of the conjunction of condition (2) expresses the deadlock reduction between automata (as introduced in Definition \ref{def:dpwd}).   

Intuitively, this means that for every pair of related
states $(s_1,s_2)$  of the two automata, and for every  transition of the first automaton from $s_1$, there is a set of matching transitions  of the second automaton  from $s_2$ such that the produced action match, the actions of the same holes and the successors are related after variable update. Our definition captures a simple kind of sub-classing of open automata with the same holes. It is stronger than a strict simulation since it matches a transition with a family of transitions. 
With such a relation we are able to check the refinement between two open automata with the same level of abstraction but specified differently, for example, by duplicating states, removing transitions,  reinforcing  guards, modifying variables. 
However, this refinement is inappropriate in the setting of composition which is the main advantage of the open automaton-based approach. 
\TODO{introduce somewhere refinement through composition} 
Refinement through composition  leads to a model in which composition can be used both to add new holes to a system and to fill holes, obtaining a system with less holes.
Next section will identify a refinement relation with the possibility to have different holes in the compared automata.\\


\TODO{Je ne suis pas sure que la def precedente soit correcte: il faut ajouter la notion de  configuration comme suit:}
 
\begin{definition}[Hole-equal simulation]
Consider two OAs \(\OAg[1]\) and \(\OAg[2]\) with  \(J_1 = J_2\), the relation on configurations \(R: S_1 \times S_2 \to \rformulas[V_1 \uplus V_2]\) is a hole-\(\symb{equal}\) simulation from $S_1$ to $S_2$ if the following conditions hold: 
\item[(1)] \(\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}}\)
\item[(2)] \(\forall \mpar{s_1, s_2} \in S_1 \times S_2,\)\vspace{-8pt}
\noindent\begin{multline*}
\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} t_1 = \OTx{1}{}{1}{1} \in \fOT{s_1},  \forall \sigma: V_1 \uplus V_2 \uplus \fvars{t_1} \to \values,\\
\bigsymb{\exists} \mpar{t_{2x} = \OTx{2}{x}{2x}{2x} \in \fOT{s_2}}^{x \in X}\!\!\!\!, 
	\exists \sigma':\biguplus_\subbox{t_{2x} \in \fOT{s_2}} \fvars{t_{2x}}   \to \values\\
		   \mpar{\forall x \in X, J'_{2x}= J'_1} \\[-2pt]
%		\nwedge  
		\left( \sigma  \vdash  R\mpar{s_1, s_2} \wedge g_1 \implies \sigma \uplus \sigma' \vdash \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_{2x}} \beta_{1j} = \beta_{2xj} \nwedge \\[12pt]
			 g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}}\right)
	\end{array} 
%\\
%	\wedge \mpar{V_1 \uplus V_2 \uplus \biguplus_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}}
\end{multline*}
\item[(3)] $R$ is deadlock reducing.
\end{definition}



%Technically,  it expresses how the concepts from the abstract and the refined systems are linked together.





\TODO{4 pages}

\section{A Refinement Relation that Takes Holes into Account}\label{sec:holes}
\TODO{3.5 pages}

Above we designed a refinement relation that compares OAs with the same holes, it ensures simulation at the automaton level, with symbolic evaluation of the guards and transitions. We want now to extend this to automata where the set of holes is not the same. A trivial use-case for this is filling a hole with a completely defined automaton. In this case, we want to ensure that the automaton with a filled hole is a refinement of the other automata: actions of the identical holes will be taken into account the same way, and filling the hole partially reduces the behaviour of the automaton.

The major challenge in this case is to maintain a form of transitivity while being able to take into account the actions of some of the holes. A naive definition of refinement would ensure that the holes that are identical in the two OAs are taken into account in the simulation. Unfortunately this does not work well with transitivity as if $A_1$ simulates $A_2$ and $A_2$ simulates $A_3$, and one hole appears in $A_3$ and in $A_1$ but not in $A_2$ then we have no proven property on the way $A_1$ and $A_3$ takes his hole into account, and in general  $A_1$ does not simulate $A_3$. The way we solve this issue is to remember in the simulation relation which holes have been compared. This way the relation is parameterized by the set of holes that belong to the two automata and are taken into account.
In practice, when performing successive refinements, we  keep track of which holes are in common at each step of refinement.
\begin{definition}[Open automata refinement]\label{Def:OA-Refinement}
For two open automata \(A_1 \defobject \OA{S_1}{s_{01}}{J_1}{V_1}{\sigma_{01}}{T_1}\) and \(A_2 \defobject \OA{S_2}{s_{02}}{J_2}{V_2}{\sigma_{02}}{T_2}\), \(A_1\) is a refinement of \(A_2\) tracking holes \(H\), noted \(\wrel{A_1}{A_2}{H}\), with \(H \subseteq J_1 \cap J_2\), if there is a deadlock reducing relation $R: \mpar{S_1 \times S_2} \to \rformulas[V_1 \uplus V_2]$ such that:
 \[\mpar{\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}}}\]
and
\begin{multline*}
 \forall \mpar{s_1, s_2} \in S_1 \times S_2, \\
	\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} \OTx{1}{}{1}{1} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{2x} \in \fOT{s_2}}^{x \in X}, \\[12pt]
		\quad \mpar{\forall x \in X, J'_{2x} \cap H = J'_1 \cap H} \\[-1pt]
		\nwedge V_1 \uplus V_2 \uplus \fvars{t_1} \vdash \mpar{R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_{2x} \cap H} \beta_{1j} = \beta_{2xj} \\
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}}} \\
	\end{array} \\
\end{multline*}

Giving \(R\) and \(H\) is sufficient to characterise the refinement, so we call \(\mpar{R, H}\) a hole-tracking simulation of \(A_1\) by \(A_2\).
Hole in \(H\) are called tracked holes.
\end{definition}
It is important to note that every action of the holes outside \(H\) is unconstrained in the related automata.
It is easy to see that the hole-equal simulation is a particular case of open automata refinement, when  $J_1=J_2=H$.


\section{Properties}\label{sec:prop}
\TODO{1.5 pages}

- reflexivity and transitivity

We will  show  that  the  refinement  is  reflexive  and  transitive,  so  it  is  a  preorder on the set of open automata.

\begin{lemma} The relation \(\wrel{}{}{H}\) is a preorder thus enables stepwise refinement.
\end{lemma}
The relation  \(\wrel{}{}{H}\) is reflexive,  \(\wrel{A}{A}{H}\),  by taking $R\mpar{s_1, s_2} \mapsto \displaystyle\bigwedge_\subbox{v \in vars(s_1)} {v=v}$ to be $s_1= s_2$  and checking the above conditions (Definition \ref{Def:OA-Refinement}), we can see that\\

- composition is a refinement (under which condition?)

- what is the property wrt deadlocks?

- congruence? a[b/j] if $a'$ refines $a$ and if $b'$ refines $b$?

- relation with fh bisimulation



\section{Conclusion}\label{sec:ccl}
\TODO{0.5 pages}


\section{a recuperer si on se rend comtpte que c'est utile}
When we will introduce refinements in Section \ref{sec:prelref}, setting an undefined variable will be considered a valid refinement, for instance a \(5\) bits register is a particular \(n\) bits register.


 \bibliographystyle{splncs04}
 \bibliography{biblio}

\end{document}