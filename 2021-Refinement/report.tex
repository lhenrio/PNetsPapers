\documentclass{article}

\usepackage{xunicode}
\usepackage{fontspec}
\usepackage[hmargin=0.5in,marginparwidth=1.5in,includemp]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{unicode-math}
\usepackage{tikz}
\usetikzlibrary{external}
% \usepackage{hyperref}
% \usepackage{xcolor}
\AtBeginDocument{\renewcommand\setminus{\smallsetminus}}
\usepackage{polyglossia}
\setmainlanguage{english}

\input{common.tex}
\input{preamble.tex}
\input{tikzmacros.tex}

% possible examples for refinement: + <= |, ; <= |
% transitions between sections

\title{Refinement for open automata}
\author{Quentin \textsc{Corradi}}

\begin{document}
\maketitle

\section{Introduction}
The model of open automata is used to give the semantic of open pNets \cite{2007.10770}.
Open pNets are not petri nets but an intermediate representation used in the VerCors project to perform verification and model checking \cite{henrio:01252323}.
Open pNets with the open automaton semantic and equivalence relation introduced in previous work \cite{2007.10770} were sucessfully used to verify BIP and GCM \cite{qin:01823507, ameurboulifa:01526055}.
However equivalences relations are not sufficient to perform model checking, refinement relations are also used.
For instance an example of open pNet where equivalence is not sufficient was encountered in ...\marginpar{Paper where the motivating example came up}.

In this article we introduce a refinement relation for open automata\marginpar{TODO: expand}.

We begin in section \ref{sec:notations} by giving some notations used throughout this paper.
Then there are several sections dedicated to define all the interesting objects and properties:
In section \ref{sec:def} we give a clean and up to date definition of open automata.
In section \ref{sec:semcompo} we recall the semantic for open automata and their composition without requiring the use of open pNets.
In section \ref{sec:proofelts} we adapt the standard properties related to refinement relation from LTS to open automata.
After that the section \ref{sec:prelref} is dedicated to progressively build a refinement relation.
Finally the section \ref{sec:refinement} introduces and analyses the refinement relation on open automata.


\section{Notations}\label{sec:notations}
Notations will be defined with the operator \(\defnotation\) and names are given with the operator \(\defobject\) as follows:
\begin{align*}
	notation\_with\_variables & \defnotation notated\_object\_using\_the\_variables \\
	name & \defobject fully\_defined\_mathematical\_object
\end{align*}

Throughout this paper, tuples might be noted differently depending on what they represent.

Family of values, or equivalently maps will be noted \(\mset{i \mapsto x_i}{i \in I}\), \(\mset{i \gets x_i}{i \in I}\) or \(x_i^{i \in I}\).
The latter will only be used when there is a generating expression; for instance \(\mpar{ax}^{x \in \setR}\) represents a scaling function, \(c^{i \in I}\) is a constant function over \(I\).
However \(\mbrc{\alpha \mapsto 1, \beta \mapsto 2, \gamma \mapsto 3}\) has no generating expression and is represented with the first notation in a finite context.
The disjoint union of two maps \(\varphi: I \to X\) and \(\psi: J \to Y\) with \(I \cap J = \emptyset\) is \(\varphi \uplus \psi: I \uplus J \to X \cup Y\).

In a formula, a quantifier followed by a finite set will be used as a shorthand for the quantification on every variable in the set:
\(\forall \mbrc{a_1, \dots, a_n}, \exists \mbrc{b_1, \dots, b_m}, P\) means \(\forall a_1, \dots, \forall a_n, \exists b_1, \dots, \exists b_m, P\).


\section{Open Automaton}\label{sec:def}
To define an open automaton we need some preliminary definitions.
\begin{defi}[Expression algebra, Action algebra, Formulae, Terms]
An expression algebra \(E\) is a disjoint union \(E \defobject \terms \uplus \actions \uplus \formulae\) of the terms, the actions and the formulae.

The terms \(\terms\) is a term algebra.
The action algebra \(\actions\) is the set of pairs \(\labels \times \terms\) where \(\labels\) are the action labels.
The formulae \(\formulae\) are at least the first order formulae over \(\terms\) and \(\labels\).
\end{defi}
The term algebra and action labels are arbitrary.
An element \(\mpar{l, t} \in \actions\) is noted \(l\mpar{t}\).
The formulae contain at least first order logic terms with an equality relation.
This equality relation is not necessarily a syntactic equality (\(2 + 2 \neq 4\) with a syntactic equality) on \(\terms\).

An example of term algebra can be Peano integers (zero, variable and successor function), the formulae associated can use equality relation, the sum relation \(\mathit{sum}\mpar{a, b, c} \defobject a = b + c\) and the product relation \(\mathit{prod}\mpar{a, b, c} \defobject a = b \times c\).

\begin{defi}[Free variables, Closed terms, Closed formulae]
\defitem \(\fvars{e}\) is the set of unbound variables in \(e \in E\).
\defitem The expressions restricted to variables in \(V\) are \(E_V \defnotation \mset{e \in E}{\fvars{e} \subseteq V}\); \(E_V \subset E\).
\defitem The closed expressions are expressions restricted to variables in \(\emptyset\), \(E_\emptyset\).
\end{defi}
Terms, actions and formulae restricted to variables and their closed versions are also defined by restriction.
A closed expression can contain variables, only unbound variable are restricted.

We can use the previous example of first order formula on Peano integers to illustrate these definitions.
\(x\), \(S\mpar{y}\) are valid terms, \(0\) is a closed term, \(\fvars{x} = \mbrc{x}\), \(\fvars{S\mpar{y}} = \mbrc{y}\), \(\fvars{0} = \emptyset\).
\(x = 0\), \(\forall y, \exists x, \mathit{sum}\mpar{y, z, x}\) are valid formulae, \(\forall x, \neg S\mpar{x} = 0\) is a valid closed formula, \(\fvars{x = 0} = \mbrc{x}\), \(\fvars{\forall y, \exists x, \mathit{sum}\mpar{y, z, x}} = \mbrc{z}\), \(\fvars{\forall x, \neg S\mpar{x} = 0} = \emptyset\).

\begin{defi}[Interpretation, Values, Satisfiability, (Parallel) substitution]
We assume that the following are given:
\defitem The values \(\values\), which are interpretations of closed terms.
\defitem The satisfiability relation on closed formulae, \({\vdash} \subseteq \rformulae\).
\defitem The substitution in \(e \in E\) of \(x \in \fvars{e}\) by \(t \in \terms\), \(e\subst{t}{x}\).
\defitem The parallel substitution in \(e \in E\) of variables in \(V\) by \(\psi: V \to \terms\), \(e\psubst{\psi}\).
\end{defi}
For the parallel substitution, the set \(V\) is not required to be a subset of \(\fvars{e}\).
In the case where it is not, the variables in \(V \setminus \fvars{e}\) are not substituted.
The substitutions might give a ill-formed expression; for instance let the terms be integers and pairs with (pointwise) addition, \(\mpar{a + b}\psubst{a \mapsto 7, b \mapsto \mpar{4, 5}}\) is a ill-formed term.
This can be guarded with the check \(e\subst{t}{x} \in E\) and \(e\psubst{\psi} \in E\) and it will implicitly be the case, for instance when there is quantification on \(t\) and \(\psi\), to simplify notations.

The interpretation of terms is supposed to be decidable.
The satisfiability of formulae might not be decidable nor complete nor consistent, however we will pretend like they are because these are really hard problems for logicians that we don't want to deal with.
For instance a formula with quantifiers on variables might not be provable even if it is true for all values of these variables.
In practise the formulae will be given to a SMT solver and we make sure they have all the previous properties.
Actually \(\vdash\) is used to separate the external logic and the logic on \(\formulae\).

Values will be used for keeping a variable state, and then injected in terms for substitution.
This is correct when \(\values \subseteq \rterms\) and we suppose it is the case.
Otherwise it doesn't invalidates theorem because it can stand as a shorthand for substitution with any term which is interpreted as \(v\).
We suppose that the interpretation of terms is compatible w.r.t.\@ substitution, that is if two terms \(t\), \(t'\) are interpreted with the same value, then replacing \(t\) by \(t'\) in a well-formed expression makes an equivalent well-formed expression.
\begin{noti}[Notations for separating external logic and logic on \(\formulae\)]
\defitem The satisfiability relation will be noted using the classical relational notation \(\vdash f\).
\defitem The satisfiability of a formula \(f \in \formulae\) under some valuation \(\sigma: V \to \values\) is noted:
\[ \sigma \vdash f \defnotation \vdash \exists \fvars{f\psubst{\sigma}}, f\psubst{\sigma} \]
\defitem The satisfiability of a formula \(f \in \formulae\) with some variable set \(V\) as context is noted:
\[ V \vdash f \defnotation \vdash \forall V, \exists\mpar{\fvars{f} \setminus V}, f \]
\defitem The precedence of \(\vdash\) is the lowest on the right side and higher than \(\uplus\) on the left side:
\[ \forall a \, b, a \uplus b \vdash x \wedge y \implies \exists z, P\mpar{x,z} \text{ is the same as } \forall a \, b, \mpar{\mpar{a \uplus b} \vdash \mpar{\mpar{x \wedge y} \implies \exists z, P\mpar{x,z}}} \]
\end{noti}
With these common definitions and notations settled, the objects of interest can now be defined.
\begin{defi}[Open automaton]
A open automaton is a tuple \(\OA{S}{s_0}{V}{\sigma_0}{J}{T}\) with \(S\) the set of states, \(s_0 \in S\) the initial state, \(V\) the set of variable names unique to this automaton, \(\sigma_0: V' \to \values\) the initial valuation of variables where \(V' \subseteq V\), \(J\) the set of hole names and \(T\) the set of open transitions.

\(S, V, J\) are arbitrary finite sets.
\end{defi}
The variable names may clash when considering two automata, in that case we suppose that we can still distinguish the variables in the formulas.
% The open transitions will be considered to be a finite set of representative open transitions. Removing this restriction may break some theorems.
The initial valuation may be a partial valuation of the variables, if the undefined variables are set before being read this behave like a normal variable.
If the undefined variable is not set before being read then its value may be any fixed value, the potential use of this construct will be explain in more details in section ???\marginpar{refinement section, hole identical is sufficient for the parametric construct}.
\begin{defi}[Open transition]
An open transition is a tuple \nmm{\OTg} with \(s, s' \in S\) the source and target states, \(\alpha \in \actions\) the produced action, \(J' \subseteq J\) the holes involved, \(\beta_j \in \actions\) the actions of the holes, \(g \in \rformulae\) the guard and \(\psi: V \to \terms\) the new value of the variables.
\end{defi}
An open transition can have many unbound variable, actually an effective transition of the automaton is any well-formed substitution of the unbound variables of the transition minus the automaton variables.
% This is used to constrain the infinite branching to be representable, making it possible to reason about.

The intuition of a semantic open automaton is a partially defined LTS with variables, guards on transitions and parametrised actions.
Initially the automaton is in the initial state with the initial valuation.
In any state with any valuation, it can perform transitions which source state is the current state and which guard is valid in the current valuation if the holes emit the indicated action.
By performing the transition the automaton emits the indicated action and updates its variables and state.

\begin{noti}[Bisimilarity, FH-bisimulation]
The bisimilarity relation on open automata is noted \(\cong\) and the FH-bisimulation \cite{henrio:01055091} is noted \(\overset{FH}=\).
\end{noti}
Note that FH-bisimilarity implies bisimilarity.

To illustrate these definitions we consider  two implementations (figure \ref{fig:enable}) of the LOTOS \cite{ISOLOTOS} operator enable in the open automata model.
The enable operator runs  the left hand side agent until it chooses to finish, at which point it produces an action \(\delta\) that is synchronised with the first action of the right hand side agent which must be \(\act{acc}\), then only the latter agent runs.
During the synchronised action \Quentin{data can be exchanged}{I need to read a little bit more on that; is that a return code?}.


\begin{exi}[Enable, state-oriented]
\begin{figure}
\centering
\input{enable_state.tex}
\vrule
\input{enable_var.tex}
\caption{Enable operator implementation with open automata, on the left state oriented, on the right variable oriented}
\label{fig:enable}
\end{figure}

Graphical notations for showing automata are as follows.
Automata are shown in the figure, the usual circle for states and simple arrows for transitions convention is used.
The initial state is indicated by a double circle.
States names are indicated inside the circles and transitions labels are drawn near their corresponding arrow.
The open transitions do not indicate the source and target states since that is the role of the transitions arrows; only the action is on the bottom side of the open transition.
Also in the example, transitions are specified using variables in place of actions.
This is used to represent all the transitions created by a correct substitution of these variables, which cannot be drawn as there are often infinitely many.

We can proceed to explain the left enable operator example.
The automata on the left side is \(\OA{\mbrc{L, R}}{L}{\emptyset}{\mbrc{}}{\mbrc{l, r}}{T}\) where transitions in \(T\) are:
\begin{align*}
	\OT{L}{L}{x}{\mbrc{l \mapsto x}}{x \neq \delta}{\mbrc{}} &&
	\OT{L}{R}{\tau}{\mbrc{l \mapsto \delta\mpar{x}, r \mapsto \act{acc}\mpar{y}}}{x = y}{\mbrc{}} &&
	\OT{R}{R}{x}{\mbrc{r \mapsto x}}{\top}{\mbrc{}}
\end{align*}
Note that we could have expressed the transition in the middle with \(\mbrc{l \mapsto \delta\mpar{x}, r \mapsto \act{acc}\mpar{x}}\) which would have avoided many transitions with trivially false guards like the one where \(x \mapsto 1, y \mapsto 2\) which has the guard \(1 = 2\).

This automaton is an implementation of the enable operator because it begins in the state \(L\) where it allows any transition from its hole \(l\) which is not \(\delta\) then the automaton synchronises its holes on the same data, effectively allowing a data exchange when it goes into state \(R\), and finally allows any transition from its hole \(r\).
We use the standard convention that uses \(\tau\) as a non-observable transition, never synchronised with other actions and passed unmodified.
This allows the synchronisation of the two holes to be hidden to the exterior by sending a \(\tau\).
However here \(\tau\) is not always allowed from the holes, for instance in the state \(L\) the hole \(r\) cannot emit it.
These transition have been omitted for the sake of simplifying the first example of open automaton.
\end{exi}

Finally we can define some utilitary functions:
\begin{defi}[Guard, Out-transition, Transition variables]
Let \(V\) be the variable names of the considered automaton, \(T\) its transitions and \(s\) be one of its states.
\(\fOT{s}\) are called the out-transitions of \(s\).
\(\fIT{s'}\) are called the in-transitions of \(s'\).
\begin{align*}
	\fOT{t} & \defnotation \mset{\OTg \in T}{s = t} &
	\fIT{t} & \defnotation \mset{\OTg \in T}{s' = t} \\
\end{align*}
\vspace{-1cm}
\begin{gather*}
	\fguard{\OTg} \defnotation g \\
	\fvars{\OTg} \defnotation \mpar{\fvars{\alpha} \cup \fvars{g} \cup \bigcup_{j \in J'} \fvars{\beta_j} \cup \bigcup_{v \in V} \fvars{\psi\mpar{v}}} \setminus V
\end{gather*}
\end{defi}

\begin{exi}[Enable, variable-oriented]
The automata drawn on the right side of the figure is an alternative implementation of the enable operator which is FH-bisimilar to the previous one.
The drawing introduces the double arrows which is used to denote the initial valuation.
The automata drawn is \(\OA{\mbrc{\_}}{\_}{\mbrc{v}}{l^\mbrc{v}}{\mbrc{l, r}}{T}\) where transitions in \(T\) are:
\begin{align*}
	\OT{\_}{\_}{x}{\mbrc{l \mapsto x}}{v = l \wedge x \neq \delta}{\mbrc{}} &&
	\OT{\_}{\_}{\tau}{\mbrc{l \mapsto \delta\mpar{x}, r \mapsto \act{acc}\mpar{y}}}{v = l \wedge x = y}{\mbrc{v \gets r}} &&
	\OT{\_}{\_}{x}{\mbrc{r \mapsto x}}{v = r}{\mbrc{}}
\end{align*}
Note that in this example \(r\) and \(l\) are a hole names and also closed terms: this is a naming conflict, we do not have \(J \subseteq \rterms\).

The variables of a transition are all the free variables in the expressions minus the automaton variables.
For instance \(v\) is a variable name for the automaton which is used in the guard.
It is not a transituon variable.
When generating transition without free variables its value is not substituted with a closed term.
For instance \nmm{\OT{\_}{\_}{\tau}{\mbrc{l \mapsto \tau}}{v = l \wedge \tau \neq \delta}{\mbrc{}}} is a transition generated by the second transition and is in \(T\) but not \nmm{\OT{\_}{\_}{\tau}{\mbrc{l \mapsto \tau}}{l = l \wedge \tau \neq \delta}{\mbrc{}}} (result of the forbidden substitution \(v \mapsto l\)).

An imaginary run of this open automaton can be the automaton in the hole \(l\) emits many actions, this synchronises with the only transition possible at that moment because \(v = l\).
Then the automaton in hole \(l\) emits a \(\delta\mpar{t}\), this is synchonised with the action that sets \(v \gets r\) and the automata in hole \(r\) must emit a \(\act{acc}\mpar{t}\).
Finally the automaton in the hole \(r\) emits any sequence of action.

Another imaginary run can be the automaton in the hole \(l\) emits a sequence of action and the automaton in the hole \(r\) cannot emit a \(\act{acc}\mpar{t}\) so it never runs.
\end{exi}

From this point open automata and open transitions will be called automata and transitions for simplicity.


\section{Semantic and composition of Open Automata}\label{sec:semcompo}
The interpretation of open automata is a partially specified automaton, where the partial specification comes from the holes.
This specification can be completed by composing automata into holes so it is natural to take a look at the composition process.
This was already defined on pNets in previous work \cite{henrio:01299562} but never completely formalised on open automata.
The  definition of composition below is a direct translation of composition on pNets for open automata.
\begin{defi}[Composition of open automata]
The composition of \(A_c \defobject \OA{S_c}{s_{0c}}{V_c}{\sigma_{0c}}{J_c}{T_c}\) in the hole \(k \in J_p\) of \(A_p \defobject \OA{S_p}{s_{0p}}{V_p}{\sigma_{0p}}{J_p}{T_p}\) is
\begin{align*}
	A_p\subst{A_c}{k} \defnotation & \OA{S_p \times S_c}{\mpar{s_{0p}, s_{0c}}}{V_p \uplus V_c}{\sigma_{0p} \uplus \sigma_{0c}}{J_c \uplus J_p \setminus \mbrc{k}}{T} \\
	\text{With } T \defobject & \mset{\OT{\mpar{s_p, s_c}}{\mpar{s'_p, s'_c}}{\alpha_p}{\beta_j^{j \in J'_c \uplus J'_p \setminus \mbrc{k}}}{g_p \wedge g_c \wedge \alpha_c = \beta_k}{\psi_p \uplus \psi_c}}{\OTx{p}{}{}{p} \in T_p, \OTx{c}{}{}{c} \in T_c} \\
	& \cup \mset{\OT{\mpar{s_p, s_c}}{\mpar{s'_p, s_c}}{\alpha_p}{\beta_j^{j \in J'_p}}{g_p}{\psi_p}}{\OTx{p}{}{}{p}, k \notin J', s_c \in S_c}
\end{align*}
Similarly to expression substitution, the parallel composition is noted \(A\psubst{A_j^{j \in J}}\).
\end{defi}
The actions emitted when \(A_c\) makes a transition is sychronised with the action of the hole \(k\) in transitions of \(A_p\) which have it as a hole actions (first transition set, \(\alpha_c = \beta_k\)).
No transition of \(A_c\) is performed when a transition that do not refer to the hole \(k\) is performed in \(A_p\) (second transition set, \(k \notin J'\)).
The composition may look like a handshake, with both automata running in parallel (product of states and joint variables) but it is actually not symmetric.
\begin{exi}
\begin{figure}
\centering
\input{Traffic_Lights_Spec.tex}
\caption{The specification of a traffic light system}
\label{fig:tls}
\end{figure}
\begin{figure}
\centering
\input{Traffic_Lights_Controller.tex}
\vrule
\input{Traffic_Lights_Register.tex}
\caption{On the left: The controller agent; On the right: The counter agent}
\label{fig:tlh}
\end{figure}
This example is derived and adapted from a traffic light controller in a collection of examples for pNets.
It is supposed to be a single traffic light.

Figure \ref{fig:tls} shows the light controller with some synchronisation logic.
It  takes an unimplemented control circuit in the hole \(ctl\) which gives the timings and an also unimplemented counter in the hole \(cnt\) to count external \(\act{tick}\) actions.
The three states are used to remember which colored light is on and this color can be retrieved by the environment by synchronising with the actions \(\act{onXxx}\) (Xxx is either Red, Yellow or Green) if it is not stored externally.

The color switches when the register and the control circuit agree that the time is over.
The new time limit can be set by the control circuit and the exposed action to the exterior is a \(\tau\).

The component we choose to compose in the holes are in Figure \ref{fig:tlh}.
On the left is the controller agent which will be composed in the hole \(ctl\).
Its role is to decide the duration before switching the lights.
This implementation is simply a constant time for each color.

On the right is the counter agent which will be composed in the hole \(cnt\).
Its role is to get a target, then count ticks until that target is reached, then emit an action with the elapsed time and restart.
This implementation does exactly that and forbids any extra tick.

\begin{figure}
\centering
\input{Traffic_Lights_Full.tex}
\caption{The full traffic lights system}
\label{fig:tlf}
\end{figure}
The automaton on Figure \ref{fig:tlf} is bisimilar to the composition of the specification on Figure \ref{fig:tls} and the agents on Figure \ref{fig:tlh}.
The result of the composition has 36 states (\(3 \times 2 \times 6\)) but only 6 are reachable from the initial configuration.
The transitions obtained by composition were simplified to give the following (where \(n, n+1\) stands for numbers between 1 and 6 and Xxx is either Red, Yellow or Green):
\begin{itemize}
\item \nmm{\OT{XnS}{X(n+1)C}{\tau}{\mbrc{}}{\top}{\mbrc{t \gets k, c \gets 0}}} which is the composition of \nmm{\OT{X}{X}{\tau}{\mbrc{ctl \mapsto \theta\mpar{x}, cnt \mapsto \act{set}\mpar{x}}}{\top}{\mbrc{}}} from the specification with \nmm{\OT{S}{C}{\act{set}\mpar{x}}{\mbrc{}}{\top}{\mbrc{t \gets x, c \gets 0}}} from the counter and \nmm{\OT{n}{n+1}{\theta\mpar{k}}{\mbrc{}}{\top}{\mbrc{}}} from the controller.
\item \nmm{\OT{XnC}{XnC}{\act{tick}}{\mbrc{}}{c < t}{\mbrc{c \gets c + 1}}} which is the composition of \nmm{\OT{X}{X}{\act{tick}}{\mbrc{cnt \mapsto \act{tick}}}{\top}{\mbrc{}}} from the specification with \nmm{\OT{C}{C}{\act{tick}}{\mbrc{}}{c < t}{\mbrc{c \gets c + 1}}} from the counter.
\item \nmm{\OT{YnC}{X(n+1)S}{\act{TurnXxx}}{\mbrc{}}{c = t}{\mbrc{}}} which is the composition of \nmm{\OT{Y}{X}{\act{TurnXxx}}{\mbrc{cnt \mapsto \act{over}\mpar{x}, ctl \mapsto \delta\mpar{x}}}{\top}{\mbrc{}}} from the specification with \nmm{\OT{C}{S}{\act{over}\mpar{c}}{\mbrc{}}{c = t}{\mbrc{}}} from the counter and \nmm{\OT{n}{n+1}{\delta\mpar{x}}{\mbrc{}}{\top}{\mbrc{}}} from the controller.
\end{itemize}

To illustrate composition, simplification and value passing, the \(\tau\) transition from the state \(R\) will be examined.
The transition in the specification is \nmm{\OT{R}{R}{\tau}{\mbrc{cnt \mapsto \act{set}\mpar{x}, ctl \mapsto \theta\mpar{x}}}{\top}{\mbrc{}}}.
The composition can produce 12 states containing the \(R\) state, these states are in \(\mbrc{R} \times \mdbrk{1; 6} \times \mbrc{S, C}\), however only \(R1S\) and \(R2C\) are reachable so we will only consider \(\tau\) transitions from these two.
The holes \(cnt\) and \(ctl\) are both involved in the \(\tau\) transition and filled with automata so the composed automata must synchronise with a transition.

In the state \(R2C\) the composition produces 2 transition by composition out of the \(\tau\) transition but both have a false guard; It is still interesting to look at one of them to show the product of composition without simplification.

\nmm{\OT{R2C}{R3C}{\tau}{\mbrc{}}{\top \wedge \top \wedge c < t \wedge \act{set}\mpar{x} = \act{tick} \wedge \theta\mpar{x} = \delta\mpar{x_C}}{\mbrc{c \gets c + 1}}} is made with \nmm{\OT{2}{3}{\delta\mpar{x}}{\mbrc{}}{\top}{\mbrc{}}} from the controller and \nmm{\OT{C}{C}{\act{tick}}{\mbrc{}}{c < t}{\mbrc{c \gets c + 1}}} from the counter.
Obviously the equality of actions in the guard cannot be satisfied so the guard is false, it is equivalent to have no transition.
We could go on to another transition but something worth explaining happened to build its guard.
The first two \(\top\) come from the guards of the specification and the controller.
\(c < t\) comes from the counter.
The rest of the guard comes from the equality constraint between holes actions and automata actions.
When composing this expression, we can see that the \(x\) variables from the specification, the controller and the counter are in conflict.
To resolve the conflict the conflicted variables are renamed depending on where they come from.

In the state \(R1S\) the composition produces 1 transition out of the \(\tau\) transition.
The simplified transition is described before, yet examining the composition process can illustrate how value passing work.
The obtained guard is \(\top \wedge \top \wedge \top \wedge \theta\mpar{x} = \theta\mpar{17} \wedge \act{set}\mpar{x} = \act{set}\mpar{x_R}\) and the obtained variable assignment is \(\mbrc{t \gets x_R, c \gets 0}\).
We can see how value passing works in the equality constraints: the only possible value of \(x\) and \(x_R\) making the guard hold is \(17\), this value has been synchronised from the controller to \(x\) then to the second occurrence of \(x\) to the distinct \(x\) of the counter.
Note that \nmm{\OT{S}{C}{\act{set}\mpar{t}}{\mbrc{}}{\top}{\mbrc{c \gets 0}}} wouldn't have worked as a transition for the controller because \(t\) is not a transition variable, its value is fixed before the transition and cannot be set outside of the variable update, hence the use of an auxiliary variable \(x\).

From this point the guard and transition will always be simplified.
\end{exi}


\section{What is a refinement for Open Automata}\label{sec:proofelts}
There are several properties that we may want from a refinement relation.
Depending on these properties, several kinds of refinement may be used.
For example if we are interested in producing the same sequence of actions we may want to use trace set inclusion as a refinement.
Here the main properties that we want are related to composition and action refinement.
Because of composition, a relation as strong as simulation refinement must be used as observed in the articles about FH-bisimulation \cite{henrio:01055091}.

% LATER
% Other kind of refinement relation that \Quentin{I may explore}{This is a note for possible path, some may be explored, some may not.} are control refinement/hole refinement\footnote{No good formulation atm, the idea is that \(a \leq b \defnotation sth \wedge J_a \setminus J_b \leq_{ctrl} J_b \setminus J_a\), sth is probably a clause to ensure that they behave the same without holes involved.}, (meet semi)lattice refinement\footnote{meet = handshake, \(a \leq b \defnotation a = a || b\) with sync holes, I think this will be equivalent to hole-identical sim, (join=non-det choice?)}, weak-simulation refinement\footnote{Weak variation for each interesting simulation refinement}, composition-correct refinement\footnote{Basically a stricter variant of simulation-refinement where simulation has to take place the other way for some transitions (no different holes?) in order to be correct wrt composition}.

The important properties we will consider here are:
\begin{defi} A relation \(\leq\) is
\defitem \textbf{reflexive} iff \(\forall a, a \leq a\);
\defitem \textbf{transitive} iff \(\forall a\, b\, c, a \leq b \wedge b \leq c \implies a \leq c\);
\defitem \textbf{a preorder} iff it is reflexive and transitive;
\defitem \textbf{correct w.r.t.\@ composition} iff \(\forall a\, b, a\mbrk{b} \leq a\);
\defitem \textbf{complete w.r.t.\@ composition} iff \(\forall a\, b, a \leq b \implies \exists c, a \overset{FH}= b\mbrk{c}\);
\defitem \textbf{context refining for composition} iff \(\forall a\, b\, c, a \leq b \implies a\mbrk{c} \leq b\mbrk{c}\);
\defitem \textbf{congruent for composition} iff \(\forall a\, b\, c, a \leq b \implies c\mbrk{a} \leq c\mbrk{b}\);
\defitem \textbf{compatible with composition} iff \(\forall a\, b\, c\, d, a \leq b \wedge c \leq d \implies c\mbrk{a} \leq d\mbrk{b}\);
\defitem \textbf{compatibile with FH-bisimulation} iff \(\forall a\, b\, c, d, a \overset{FH}= b \wedge c \overset{FH}= d \wedge a \leq c \implies b \leq d\).
\end{defi}
Reflexivity, transitivity and preorder are classical properties on relations.
Correctness w.r.t.\@ composition is the fact that every composition is considered a refinement.
Completeness w.r.t.\@ composition is the fact that a refinement correspond to the left automaton being equivalent to some composition of the right automaton.
Context refinement is the refinement being compatible with composition of the same automaton.
Congruence is the refinement being compatible with being composed in the same automaton.
Compatibility with composition is the conjunction of the two latter (assuming the relation is a preorder).
Finally compatibility with FH-bisimulation is the refinement not being able to distinguish two FH-bisimilar automata.

The relations will have to be at least preorders, simulations and forbid the introduction of deadlocks (state where no transition is possible) to be called refinement simulation.
On top of that weak refinement are refinement where some actions, typically one named \(\tau\), are considered not observable and can occur in the implementation while not having to be matched in the specification.
In the weak refinement the relations have to forbid the introduction of livelocks (only a sequence of \(\tau\) possible) and respect \(\tau\)-stuttering \marginpar{cite many things arround here}.
While being preorder is simple to express for a relation, being a simulation, do not introduce new deadlocks/livelocks and \(\tau\)-stuttering are properties about the states of the related automata, therefore they are more complex to express.
We will need a preliminary concept before defining them.
\begin{defi}[Relation under predicate]
A relation under predicate between states of two automata \(\OA{S_1}{s_{01}}{J_1}{V_1}{\sigma_{01}}{T_1}\) and \(\OA{S_2}{s_{02}}{J_2}{V_2}{\sigma_{02}}{T_2}\) is a function \(R: S_1 \times S_2 \to \rformulae[V_1 \uplus V_2]\).

Two states \(s_1 \in S_1, s_2 \in S_2\) are related under a valuation \(\sigma: V_1 \uplus V_2 \to \values\) iff \(\sigma \vdash R\mpar{s_1, s_2}\).
For a relation \(\wrel{}{}{}\) which uses a relation under predicate to prove that two element are related \(\forall x \, x', x \wrel{}{}{} x' \iff \exists R, P\mpar{R}\), the fact that there is a valid witness \(R\) is noted \(\wrel{x}{x'}{R}\).
\end{defi}
Now the properties about states of automata can be adapted to open automata.
\begin{defi}[Simulation on open automata]
A relation \(\leq\) is a simulation if for any related automata \(\wrel{A_1}{A_2}{R}\) where \(A_1 \defobject \OA{S_1}{s_{01}}{J_1}{V_1}{\sigma_{01}}{T_1}\), \(A_2 \defobject \OA{S_2}{s_{02}}{J_2}{V_2}{\sigma_{02}}{T_2}\) and \(R: S_1 \times S_2 \to \rformulae[V_1 \uplus V_2]\), \(R\) satisfies both
\defitem Initial states are related under initial valuations: \(\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}}\);
\defitem From related states, all out-transitions from \(A_1\) can be simulated in \(A_2\) and their target states are related:
\begin{multline*}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \bigsymb{\forall} t_1 \defobject \OTx{1}{}{1}{1} \in \fOT{s_1}, \forall \sigma: V_1 \uplus V_2 \uplus \fvars{t_1} \to \values, \\
	\mpar{\sigma \vdash R\mpar{s_1, s_2} \wedge g_1} \implies \bigsymb{\exists} t_2 \defobject \OTx{2}{}{2}{2} \in \fOT{s_2}, \exists \nu: \fvars{t_2} \to \values, \\
	\sigma \uplus \nu \vdash \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge g_2 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2}
\end{multline*}
\end{defi}
The last formula means that for every pair of related states under valuation of the automaton variables and every possible transitions (\(\vdash g_1\)) from the first automaton, there is a possible transition (\(\vdash g_2\)) such that the produced action matches (\(\alpha_1 = \alpha_2\)), the holes actions from same hole names (\(J'_1 \cap J'_2\)) match (\(\beta_{1j} = \beta_{2j}\)) and the target states are related after variable update.
This is a natural extenion of the notion of simulation on LTS, which is the same definition without variables and holes and guards.
It will serve as a watchdog for any relation that will be defined with ``simulation" in its name, except weak-simulation where the transition from the first automaton that produce \(\tau\) actions are excluded.

\begin{defi}[Deadlock reduction, intuitive definition]
A simulation \(\leq\) is deadlock reducing if in all the \(R: S_1 \times S_2 \to \rformulae[V_1 \uplus V_2]\) such that \(\wrel{A_1}{A_2}{R}\), there is one that also satisfies
\begin{multline*}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \forall \sigma: V \to \values, \mpar{\sigma \vdash R\mpar{s_1, s_2}} \implies \\
	\mpar{\everymath{\displaystyle}\begin{array}{c}
		\bigsymb{\exists} t_1 \defobject \OTx{1}{}{1}{1} \in \fOT{s_1}, t_2 \defobject \OTx{2}{}{2}{2} \in \fOT{s_2}, \exists \nu: \fvars{t_1} \uplus \fvars{t_2} \to \values, \\
		\sigma \uplus \nu \vdash g_1 \wedge g_2 \wedge \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2}
	\end{array}} \\
	\vee \forall t_2 \in \fOT{s_2}, \forall \nu: \fvars{t_2} \to \values, \sigma \uplus \nu \nvdash \fguard{t_2}
\end{multline*}
\end{defi}
This definition extends the requirements of a simulation by requiring from the relation that on related states, either there is a pair of possible matching transition or there was no out-transition possible in the specification.
This requirement effectively prevents the presence of deadlock state in the first automaton if there is a related non-deadlock state in the second.

% LATER: livelock and tau-stuttering
% \item[Livelock reduction:] If \(a \leq b\) then \(a\) does not introduces new livelocks, noted \(a \preceq b\) in the following; % Find a better place to introduce a better definition of livelock reduction.
% \defitem \textbf{\(\tau\)-stuttering} iff .

% LATER: modify or remove it
% On the other hand there is a property that we considered for some time, that may arise when designing a refinement relation and that is interesting but actually unwanted:
% \begin{description}
% \item[Daisy equivalence:] \(a\mbrk{D} \leq a \wedge a \leq a\mbrk{D}\), where \(D\) is the single state automaton that can produce any action.
% \end{description}
% This property state that composing a hole with an automaton which can do anything is not a strict refinement.
% While it might seem to be a natural property because this automaton is the closest to the meaning of a hole in term of automaton, there is actually a difference between the two.
% Daisy equivalence allows to refine by filling a hole but also by going the other way, that is creating a hole name and putting its hole action to any transition (and possibly keeping any of the unmodified transitions).
% The unwanted behaviour arise for instance when two independant holes are filled, then a hole is created and its actions are put where the two other actions were.
% This effectively merges independant holes, or equivalently allows to consider that an automaton can be plug simultaneously into several holes which is not part of the composition semantics.
% \begin{exi}
% \end{exi}

``Deadlock reduction" conflicts with ``composition completeness" by disallowing some unwanted cases where an automaton in a hole cannot produce any action that any out-transitions expects.
In particular filling a hole with the deadlock automaton (only one state without out-transitions) is not considered a refinement for a no deadlock reducing simulation refinement.
A way to solve this issue is to caracterise a composition that do not introduce deadlocks, which will be used instead of the composition introduced earlier.
\begin{defi}[Reachability]
For any open automata \(A \defobject \OA{S}{s_0}{V}{\sigma_0}{J}{T}\), a reachability predicate \(\reach{A}: S \to \rformulae[V]\) is a predicate on states such that
\defitem \(\sigma_0 \vdash \reach{A}\mpar{s_0}\).
\defitem \nmm{\bigsymb{\forall} t \defobject \OTg \in T, \forall \nu: \fvars{t} \to \values, \nu \vdash \reach{A}\mpar{s} \wedge g \implies \reach{A}\mpar{s'}\psubst{\psi}}.
\end{defi}
For the reader not used to simulations and bisimulations, this definition of a predicate can seem strange.
The reachability predicate is used to caracterise the states and valuations that are reachable in a run of an automaton.
In fact the role of the predicate is to caracterise potentially reachable configurations without having to caracterise the fact that the state and valuation are the result of a valid path in an automaton.

To do that we impose that the initial state is reachable in the initial valuation and that reachability is preserved by taking valid transitions.
This effectively makes reachability account for all paths and potentially over-approximate the reachable configurations.
However the exact rechability may not be reprensentable in the formulae, hence the need of potentially over-approximating.

Another way of understanding this predicate is that it is a fixpoint of the union of valuations that contains the initial valuation:
\begin{align*}
	f\mpar{p} = s' \mapsto p\mpar{s'} \vee \bigsymb{\bigvee_\subbox{\OTg \,\in\, \fIT{s'}}} p\mpar{s}\psubst{\psi} \wedge g &&
	\sigma_0 \vdash \reach{A}\mpar{s_0} &&
	f\mpar{\reach{A}} = \reach{A}
\end{align*}

\begin{defi}[Non-locking composition, intuitive definition]
The composition resulting in \(A_p\subst{A_c}{k} = \OA{S}{s_0}{V}{\sigma_0}{J}{T}\) with \(A_c \defobject \OA{S_c}{s_{0c}}{V_c}{\sigma_{0c}}{J_c}{T_c}\), \(A_p \defobject \OA{S_p}{s_{0p}}{V_p}{\sigma_{0p}}{J_p}{T_p}\) and \(k \in J_p\), is a non-locking composition if there is a rechability predicate such that from reachable configurations, either a transition is possible in \(A_p\subst{A_c}{k}\) or there were no possible transition in \(A_p\) to begin with
\begin{multline*}
	\forall s \in S, \forall \sigma: V \to \values, \mpar{\sigma \vdash \reach{A_p\subst{A_c}{k}}\mpar{s}} \implies \mpar{\exists t \in \fOT{s}, \exists \nu: \fvars{t} \to \values, \sigma \uplus \nu \vdash \fguard{t}} \\
	\vee \forall t_p \in \fOT{\pi_{S_p}\mpar{s}}, \forall \nu: \fvars{t_p} \to \values, \sigma \uplus \nu \nvdash \fguard{t_p}
\end{multline*}
\end{defi}

To illustrate the introduction of a deadlock in a composition and the definition of non-locking composition, let's look at an example.
\begin{exi}[Deadlocks introduced by composition]
% TODO: give a context, a circuit cannot block physical time from progressing
\begin{figure}
\input{randomtick_clock.tex}
\vrule
\input{register_anytick.tex}
\caption{On the left: A clock which imposes a tick; On the right: A modified version of the counter at figure \ref{fig:tlh}}
\label{fig:anytick}
\end{figure}
% TODO: explain
\begin{figure}
\input{Composition_deadlock.tex}
\vrule
\input{Composition_nolock.tex}
\caption{On the left: Deadlocks introduced by composition; On the right: No deadlock introduced by composition}
\label{fig:deadlock}
\end{figure}
% TODO: explain
\end{exi}

When expanding the aliases \(S, i, V\) in the definition, and remarking that the last existential quantifier can be unfolded into a transition in \(A\) and one in \(A_p\) with the added condition that they match, the definition become mildly similar with the deadlock reduction one.
It is not a coincidence because their goal is to caracterise the same kind of compatibility between automata.
Actually it is possible to simplify both definition and make them even more similar.

\begin{defi}[Deadlock reduction, working definition] % TODO HERE: Maybe there is a union vars OT(s_2) missing in the domain of sigma
A simulation \(\leq\) is deadlock reducing if in all the \(R: S_1 \times S_2 \to \rformulae[V_1 \uplus V_2]\) such that \(\wrel{A_1}{A_2}{R}\), there is one that also satisfies
\begin{multline*}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \forall \sigma: V_1 \uplus V_2 \uplus \bigcup_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \to \values, \\
	\sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}
\end{multline*}
\end{defi}
\begin{lem}
The intuitive and working definition of deadlock reduction are equivalent.
\end{lem}

\begin{defi}[Non-locking composition, working definition]
The composition \(A \defobject A_p\subst{A_c}{k}\) is a non-locking composition if:
\[ \forall s \in S, \forall \sigma: V \uplus \bigcup_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \to \values, \sigma \vdash \reach{A}\mpar{s} \wedge \bigvee_\subbox{t_p \in \fOT{\pi_{S_p}\mpar{s}}} \fguard{t_p} \implies \bigvee_\subbox{t \in \fOT{s}} \fguard{t} \]
\end{defi}
\begin{lem}
The intuitive and working definition of non-locking composition are equivalent.
\end{lem}
Proof of both lemma are given in appendix \ref{apx:lemeqd}.

% TODO?: sufficient condition

This new substitution can replace the standard substitution in the case where only one hole is filled and also in the parallel case.
In the parallel case the condition is checked after the parallel substitution because there is no guarantee that any order of sequential composition is non-locking for every substitution even if the parallel substitution is non-locking.
\begin{exi} % TODO
\begin{figure}
\centering
\input{}
\vrule
\input{}
\vrule
\input{}
\caption{}
\label{fig:pnls}
\end{figure}
An example of non-locking parallel substitution where no individual substitution is non-locking is given in Figure \ref{fig:pnls}.% TODO HERE
\end{exi}
From this point and in the previous definitions, composition will only refer to non-locking composition.

With all these properties we can now look at some concrete refinemet relations.


\section{Preliminary refinement relations}\label{sec:prelref}
The main goal of this section is to help the reader understand the problems, constraints and different elements involved to solve them so that they are not all introduced at once in the real refinement relation.
The main objective of the refinement relations in this section is to be able to say that a composition of two automata is a refinement of the base automaton (\(a\mbrk{b} \leq a\)) in restricted interesting cases.
Hopefully they can be used as simpler (and less expensive) versions of the real refinement relation in the case the manipulated automata respect the constraints.

Composing an open automaton can give an automaton where not much can be said in terms of hole indicies.
So looking at restricted cases where holes are related in a specific manner can help understanding the general case.
For two open automata \(A_1 \defobject \OA{S_1}{s_{01}}{J_1}{V_1}{\sigma_{01}}{T_1}\) and \(A_2 \defobject \OA{S_2}{s_{02}}{J_2}{V_2}{\sigma_{02}}{T_2}\), the following refinement relations are defined.

This relation is the basis for all the other ones.
It applies on automaton with same holes.
The goal is to caracterise open automata that have a more determined (more deterministic) behaviour without adding deadlocks.
\begin{defi}[Hole-identical refinement] % TODO: transition variables
If \(J_1 = J_2\) then ``\(A_1\) is a hole-identical refinement of \(A_2\)", noted \(A_1 \leq_= A_2\), is defined as:
\[ \exists R: \mpar{S_1 \times S_2} \to \rformulae[V_1 \uplus V_2], \sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}} \qwedge R \text{ hole-identical simulation of } A_1 \text{ in } A_2 \]
\end{defi}
As in other simulation-like relations, \(R\) is a witness of \(A_1 \leq_= A_2\).
The standard requirements for (bi)simulations are that \(R\) relates initial states, transitions can be matched, and target of matched transitions with related sources are also related.
For a bisimulation transitions are matched one-to-many from each automaton to the other, but for a simulation only one way is used.
The definition above requires explicitely that initial states are related, the other requirement are encapsulated in the definition (below) of hole-identical simulation.

The specificities of open automata comes in when relating the (initial) states.
The relation \(R\) relates \(i_1\) to \(i_2\) under the condition that the curent value of variables satisfies \(R\mpar{i_1, i_2}\).
If two states \(s_1 \in S_1, s_2 \in S_2\) are not(/never) related then \(\nvdash R\mpar{s_1, s_2}\).
The predicate \(R\mpar{i_1, i_2}\) is used to take into account the fact that a state is also constituted of the value of the variables.
This is already used in FH-bisimulation introduced in previous articles about open automata.
So the meaning of \(\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}}\) is that the initial states with the initial valuation are effectively related.
\begin{defi}[Hole-identical simulation]
\Quentin{``\(R\) is a hole-identical simulation of \(A_1\) in \(A_2\)"}{Any idea on how to note that? \(R \vDash A_1 \leq_= A_2\) for instance.} is defined as: % TODO: \wrel
\begin{multline*}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \\
	\mpar{\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} t_1 \defobject \OTx{1}{}{1}{} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{} \in \fOT{s_2}}^{x \in X}, \\[12pt]
		\forall \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\
		\quad \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'} \beta_{1j} = \beta_{2xj} \\[12pt]
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}} \\[12pt]
	\end{array}} \\
	\wedge \forall \sigma: \mpar{V_1 \uplus V_2} \to \values, \sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}
\end{multline*}
\end{defi}
The first two lines quantify on source states, transitions (and target states) and source states valuations.
The 3\textsuperscript{rd} line is the condition to ensure that transitions are not matched to incompatible ones:
For all variable assignement of the two automata and all hole actions (quantification of \(\sigma\)), assuming that the states were related and the transition in \(A_1\) is possible (\(R\mpar{s_1, s_2} \wedge g_1\) part) then there is always a transition, not necessarily only one, which can be performed (\(g_{2x}\)), produce the same action (\(\alpha_1 = \alpha_{2x}\)), accept the same action from the holes (\(\beta_{1j} = \beta_{2xj}\)) and satisfy the predicate for relating the target states after variable update (\(R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}\)).

The notion of refinement here is stating that \(A_1\) is a refinement of \(A_2\) if \(A_1\) can be simulated in \(A_2\).
The hole-identical part is referring to the fact that holes indicies are the same and identical holes indicies have to perform the same actions.
On top of that the last line ensures no deadlock introduction.
It can be interpreted ``assuming the predicate holds and there is any possible transition in \(A_2\) (= no deadlock), then there must be a possible transition in \(A_1\) (= no deadlock)".
It does not have to ensure that this transition isn't garbage or that the target states are related because the first part of the simulation already does it.
Also if there was a deadlock then there is no transition because no trasition can be simulated in a deadlock, that's why it is more a deadlock equivalence than a deadlock reduction.

\begin{exi} % TODO
\end{exi}

\begin{lem}[Equivalent definition]
\begin{gather*}
\forall \mpar{s_1, s_2} \in S_1 \times S_2, \\
\mpar{\everymath{\displaystyle}\begin{array}{l}
	\bigsymb{\forall} t_1 \defobject \OTx{1}{}{1}{} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{} \in \fOT{s_2}}^{x \in X}, \\[12pt]
	\forall \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\
	\quad \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
		\alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'} \beta_{1j} = \beta_{2xj} \\[12pt]
		\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
	\end{array}}
\end{array}} \\
\iff \\
\mpar{\everymath{\displaystyle}\begin{array}{l}
	\bigsymb{\forall} t_1 \defobject \OTx{1}{}{1}{1} \in \fOT{s_1}, \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\[6pt]
	\quad \mpar{\sigma \vdash R\mpar{s_1, s_2} \wedge g_1} \implies \bigsymb{\exists} \OTx{2}{}{2}{2} \in \fOT{s_2}, \\[12pt]
	\qquad \sigma \vdash \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge g_2 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2}
\end{array}}
\end{gather*}
\end{lem}
The first property is one part of the hole-identical simulation, the second property is the central part of the refinement simulation requirement.
If we prove the direct way of this equivalence and \(\leq_=\) is a preorder then \(\leq_=\) is a refinement simulation.
The other way is there because I hope that it will be easier to use this formulation to prove that \(\leq_=\) is a preorder. % Will need to be modified
One may wonder why it was not used in the definition if it is equivalent.
The reason is that the formulation used is compatible with SMT solver, the place where it will most probably be used in practise.
\begin{proof} Let \(\mpar{s_1, s_2} \in S_1 \times S_2\),
\item[\(\implies\):] We admit the up formula as \(H_{def}\), let \(t_1 \defobject \OTx{1}{}{1}{1} \in \fOT{s_1}\) and \(\sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values\) be such that \(H_{source} \defobject \sigma \vdash R\mpar{s_1, s_2} \wedge g_1\).
	\(H_{def}\) applied to \(t_1\) gives \(\mpar{t_{2x} \defobject \OTx{2}{x}{2x}{1} \in \fOT{s_2}}^{x \in X}\) and the property \(H_{tmp}\) to which we give \(\sigma\) to get
	\begin{multline*}
		H_{smt} \defobject \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \\
		\operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'_1} \beta_{1j} = \beta_{2xj} \\[12pt]
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}}
	\end{multline*}
	Unfolding the definition of \(\sigma \vdash f\) where \(f\) is not a closed formula in \(H_{smt}\) gives an exists that we use to get \nmm{\nu: \biguplus_{x \in X} \fvars{t_{2x}} \to \values} and
	\[ H_{valid} \defobject \sigma \uplus \nu \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
		\alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'_1} \beta_{1j} = \beta_{2xj} \\[12pt]
		\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
	\end{array}} \]
	\(R\mpar{s_1, s_2} \wedge g_1\) in \(H_{valid}\) does not depends on \(\nu\) so we can use \(H_{source}\) to prove it and get \(H_{cover}\).
	\(H_{cover}\) is a disjunction that we can eliminate, action that gives a value \(x\) and
	\[ H_{target}\mpar{x} \defobject \sigma \uplus \nu \vdash \alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'_1} \beta_{1j} = \beta_{2xj} \wedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}} \]
	Now that we have a specific \(x\) we can say that in the bottom formula \(t_{2x}\) is a witness in \(T_2\).
	By doing that, what we are left to prove is \nmm{\sigma \vdash \alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_1} \beta_{1j} = \beta_{2xj} \wedge g_2 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2}}.
	As a valuation for variables in \(\fvars{t_{2x}}\) we have \(\nu\), so \(H_{target}\mpar{x}\) concludes the proof.
\item[\(\impliedby\):] We admit the bottom formula as \(H_{ref}\), let \(t_1 \defobject \OTx{1}{}{1}{} \in T_1\) % TODO HERE; quantify on all valuations to get t_{2\sigma}
\end{proof}

\begin{thm} The hole-identical refinement relation is a preorder. \end{thm}
\begin{proof}
\item \emph{Reflexivity:} Let \(A\) be an open automaton with variables in \(V\).
	The automaton variables on the right hand side of the relation will be noted \(v'\) for the equivalent variable \(v \in V\) in the automaton on the left hand side.
	The simulation \nmm{R = \mset{\mpar{s, s} \mapsto \bigwedge_{v \in V} v = v'}{s \in S_1}} is a witness of \(A \leq A\).
	Checking it is a simple exercise left to the reader in order to understand how the definition works.
\item \emph{Transitivity:} Let \(A_1, A_2, A_3\) be open automata with respectively variables in \(V_1, V_2, V_3\) and states \(S_1, S_2, S_3\).
	And let \(R_{12}\) be a witness of \(A_1 \leq_= A_2\) and \(R_{23}\) be a witness of \(A_2 \leq_= A_3\).
	\[ R_{13}\mpar{s_1, s_3} \defobject \exists V_2, \bigvee_{s_2 \in S_2} R_{12}\mpar{s_1, s_2} \wedge R_{23}\mpar{s_2, s_3} \]

	Now let's prove that \(R_{13}\) is a witness of \(A_1 \leq_= A_3\):
	\begin{itemize}
	\item % TODO
	\end{itemize}
\end{proof}
% TODO Properties: do not forget to add deadlock equivalence in the 3 theorems
\begin{thm}[Hole-identical refinement correction]
% TODO: Préordre, action-refinement possible, pas de nouveau deadlock, pas de nouveau livelock, chaque état (accessible) a son correspondant (simulation)
\end{thm}
\begin{proof}
\end{proof}

The goal of the following relation is to capture the case where holes are filled with automata that do not have any hole.
It is supposed to be a relation for which filling holes with fully specified automata is a considered refinement.
\begin{defi}[Hole-subset refinement]
If \(J_1 \subseteq J_2\) then ``\(A_1\) is a hole-subset refinement of \(A_2\)", noted \(A_1 \leq_\subseteq A_2\) is defined as:
\[ \exists R: \mpar{S_1 \times S_2} \to \rformulae[V_1 \uplus V_2], \sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}} \wedge R \text{ hole-subset simulation of } A_1 \text{ in } A_2 \]
\end{defi}
This definitions is essentially the same as the hole-identical one excepted the constraint on holes which has been softened.

\begin{defi}[Hole-subset simulation]
``\(R\) is a hole-subset simulation of \(A_1\) in \(A_2\)" is defined as:
\begin{multline*}
	\forall s_1 \in S_1, s_2 \in S_2, \\
	\mpar{\renewcommand\arraystretch{1.4}\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} \OTx{1}{}{1}{1} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{2x} \in \fOT{s_2}}^{x \in X}, \\
		\mpar{\forall x \in X, J'_1 = J'_{2x} \cap J_1} \wedge \forall \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\
		\quad \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_{j \in J'_1} \beta_{1j} = \beta_{2xj} \\
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}} \\
	\end{array}} \\
	\wedge \forall \sigma: \mpar{V_1 \uplus V_2} \to \values, \sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_2}
\end{multline*}
\end{defi}
The difference with the hole-identical simulation is that the holes involved in the matched transitions don't have to be exactly the same anymore.
The new constraint is that the holes in common (that is \(J'_1\)) should be involved at the same time and their action have to match.
What happens on the other holes is unspecified except for the fact that, by being free variables they still need to be valued such that the transition is possible.

\begin{exi} % TODO: Traffic light example
\end{exi}

An alternative version of this definition could enforce \(\exists J'_2 \subseteq J_2, \forall x \in X, J'_{2x} = J'_2\).
Let's call it the alternative hole-subset simulation.
This version would mean that the holes involved in every matched transitions must be the same.
While this may seem more natural this leads to the unwanted behaviour that an automaton FH-bisimilar to a refinement of some specification might not be a refinement of that specification:
\begin{prop}[Alternative hole-subset simulation is not compatible with FH-bisimulation]
TODO: collapse a transition that was differenciated by having one filled hole involved and it should be simple
\end{prop}
This is a sufficient reason to discard this version although it seems more natural.
\begin{prop}[Hole-subset refinement is compatible with FH-bisimulation]
% TODO
\end{prop}

% Hole-subset refinement can be used to specify behaviour/constraints on holes (like an API: first do anything not involving the api, then initialise the api, then do whatever you want that do not unload the api, then unload the api by returning to the first state), then have a relation for every hole with a different automata and this means well behaving with respect to the environement (holes)
\begin{exi} % TODO
\end{exi}

\begin{prop}[Hole-subset refinement is an extension of hole-identical refinement]
Hole-subset refinement and hole-identical match when holes are identical.
\end{prop}
\begin{proof}
When \(J_1 = J_2\), \(J'_1 = J'_{2x} \cap J_1 \iff J'_1 = J'_{2x} \cap J_2 \iff J'_1 = J'_{2x}\), which is the implicit constraint on hole actions in the hole-identical simulation.
By that rewriting their definition match.
\end{proof}
Let's assume that this relation is also correct, the proof of correctness is given later for a more general refinement relation.
\begin{thm}[Composition is a refinement]
% TODO: Proof that filling holes with a fully specified automaton is a refinement
\end{thm}
\begin{proof}
\end{proof}
\begin{thm}[Context refinement]
% a <= b & a[c] <= a -> a[c] <= b[c]
\end{thm}
\begin{proof}
\end{proof}
\begin{thm}[Congruence with composition]
% a <= b & c[a] <= c -> c[a] <= c[b]
\end{thm}
\begin{proof}
\end{proof}

% TODO: Give an example of what you want to capture BEFORE and after the relation
The goal of the following relation is to capture the case where holes are filled with one hole automata.
It is supposed to be a relation for which filling holes with one hole automata is a considered refinement.
\begin{defi}[Hole-matching refinement]
If \(\card{J_1} = \card{J_2}\) then ``\(A_1\) is a hole-matching refinement of \(A_2\)", noted \(A_1 \leq_\# A_2\) is defined as:
\begin{multline*}
	\exists R: \mpar{S_1 \times S_2} \to \formulae, \quad \exists f: J_1 \setminus J_2 \to J_2 \setminus J_1, \\
	\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}} \qwedge f\mpar{J_1 \setminus J_2} = J_2 \setminus J_1 \\
	\wedge R \text{ hole-f-matching simulation of } A_1 \text{ in } A_2
\end{multline*}
\end{defi}
This definitions is essentially the same as the hole-identical except that the constraint on holes has been softened and it is compensated with a invertible map between non-shared holes.

\begin{defi}[Hole-f-matching simulation]
\(R\) is a hole-f-matching simulation of \(A_1\) in \(A_2\) is defined as:
\begin{multline*}
	\forall s_1 \in S_1, s_2 \in S_2, \\
	\mpar{\renewcommand\arraystretch{1.4}\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} \OTx{1}{}{1}{1} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{2x} \in \fOT{s_2}}^{x \in X}, \\
		\mpar{\forall x \in X, J'_1 \cap J_2 = J'_{2x} \cap J_1 \wedge f\mpar{J'_1 \setminus J_2} \subseteq J'_{2x}} \wedge \forall \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\
		\quad \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_1 \cap J_2} \beta_{1j} = \beta_{2xj} \\
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}} \\
	\end{array}} \\
	\wedge \forall \sigma: \mpar{V_1 \uplus V_2} \to \values, \sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}
\end{multline*}
\end{defi}
% TODO: Matching a hole data with another hole is done with a_1=a_2x and constraint on respective variables, thus hole data is not uncontrained, same for action label because each transition has only 1 action label
% TODO: Explain what happens on holes constraints and action constraints
% J'_1x still necessary for the same reason essentially
% f() subset J'1 \ J2 : equality is possible and give a valid alternative that must match each action with another action, even if the latter has no more the choice, basically the version given here allows to hide some choices from the hole


\section{Refinement relation for open automata}\label{sec:refinement}
% meaning of f, what happens depending on f
% hole function from implem to spec on disjoint holes
\begin{defi}[Open automata refinement]
For any two open automata \(A_1 \defobject \OA{S_1}{s_{01}}{J_1}{V_1}{\sigma_{01}}{T_1}\) and \(A_2 \defobject \OA{S_2}{s_{02}}{J_2}{V_2}{\sigma_{02}}{T_2}\), ``\(A_1\) is a refinement of \(A_2\)", noted \(A_1 \leq A_2\), is defined as:
\begin{multline*}
	\exists R: \mpar{S_1 \times S_2} \to \rformulae[V_1 \uplus V_2], \exists f: J_1 \setminus J_2 \to J_2 \setminus J_1, \\
	\sigma_{01} \uplus \sigma_{02} \vdash R\mpar{s_{01}, s_{02}} \wedge R \text{ f simulation of } A_1 \text{ in } A_2
\end{multline*}
\end{defi}

\begin{defi}[f simulation]
\(R\) is a f simulation of \(A_1\) in \(A_2\) is defined as:
\begin{multline*}
	\forall s_1 \in S_1, s_2 \in S_2, \\
	\mpar{\renewcommand\arraystretch{1.4}\everymath{\displaystyle}\begin{array}{l}
		\bigsymb{\forall} \OTx{1}{}{1}{1} \in \fOT{s_1}, \bigsymb{\exists} \mpar{\OTx{2}{x}{2x}{2x} \in \fOT{s_1}}^{x \in X}, \\
		\mpar{\forall x \in X, J'_1 \cap J_2 = J'_{2x} \cap J_1 \wedge f\mpar{J'_1 \setminus J_2} \subseteq J'_{2x}} \wedge \forall \sigma: \mpar{V_1 \uplus \fvars{t_1} \uplus V_2} \to \values, \\
		\quad \sigma \vdash R\mpar{s_1, s_2} \wedge g_1 \implies \operatorname*{\bigsymb{\bigvee}}_{x \in X} \mpar{\begin{array}{l}
			\alpha_1 = \alpha_{2x} \wedge \bigwedge_\subbox{j \in J'_1 \cap J_2} \beta_{1j} = \beta_{2xj} \\
			\nwedge g_{2x} \wedge R\mpar{s'_1, s'_{2x}}\psubst{\psi_1 \uplus \psi_{2x}}
		\end{array}} \\
	\end{array}} \\
	\wedge \forall \sigma: \mpar{V_1 \uplus V_2} \to \values, R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1}
\end{multline*}
\end{defi}
% refinement relation definition
% Explain definition, really needed
The objective of the first part of this definition is to be able to simulate \(A_1\) in \(A_2\) when holes of the same name receive the same closed automaton while other holes receive ``compatible" closed automata.
% safety is no longer trivial, prove the safety
The objective of the other part of this definition is to prevent the appearance of new deadlocks, which should mean with the first property that the compared automaton are deadlock equivalent.
% Expected properties: no new deadlocks, every path can be simulated (safety), composition that do not introduce deadlock is refinement, congruence wrt composition 2-way, most refined are runs


\section{New equivalence relation induced by pre-order}
% FH-behaviourial equivalence if hole functions are not inverse, almost-FH-bisim if function is bijective and FH-bisim if in emptyset -> emptyset


\section{Conclusion}

\pagebreak
\bibliographystyle{plain}
\bibliography{biblio}

\pagebreak
\appendix
\part*{Appendix}

\section{Proof of equivalent definitions}\label{apx:lemeqd}
\begin{proof}[Lemma 1]
Let \(R\), \(A_1 \defobject \OA{S_1}{s_{01}}{V_1}{\sigma_{01}}{J_1}{T_1}\), \(A_2 \defobject \OA{S_2}{s_{02}}{V_2}{\sigma_{02}}{J_2}{T_2}\) be such that:
\[ \wrel{A_1}{A_2}{R} \hyp{0} \]
We want to prove:
\begin{multline}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \forall \sigma: V_1 \uplus V_2 \uplus \bigcup_\subbox{t_2 \in \fOT{s_2}} \fvars{t_2} \to \values, \\
	\sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1} \tag{WD}\label{eq:WD}
\end{multline}
\[ \iff \]
\begin{multline}
	\forall \mpar{s_1, s_2} \in S_1 \times S_2, \forall \sigma: V \to \values, \mpar{\sigma \vdash R\mpar{s_1, s_2}} \implies \\
	\mpar{\everymath{\displaystyle}\begin{array}{c}
		\bigsymb{\exists} t_1 \defobject \OTx{1}{}{1}{1} \in \fOT{s_1}, t_2 \defobject \OTx{2}{}{2}{2} \in \fOT{s_2}, \exists \nu: \fvars{t_1} \uplus \fvars{t_2} \to \values, \\
		\sigma \uplus \nu \vdash g_1 \wedge g_2 \wedge \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2}
	\end{array}} \\
	\vee \forall t_2 \in \fOT{s_2}, \forall \nu: \fvars{t_2} \to \values, \sigma \uplus \nu \nvdash \fguard{t_2} \tag{ID}\label{eq:ID}
\end{multline}
\item[\bf(\ref{eq:WD})\(\implies\)(\ref{eq:ID}):]
	Let \(\mpar{s_1, s_2} \in S_1 \times S_2\) and \(\sigma: V \to \values\) be such that:
	\[ \sigma \vdash R\mpar{s_1, s_2} \hyp{1} \]
	By excluded middle, either the right hand side of the disjunction in (\ref{eq:WD}) holds, in which case the property holds, or it is false and we have the hypothesis:
	\[ \exists t_2 \in \fOT{s_2}, \exists \nu: \fvars{t_2} \to \values, \sigma \uplus \nu \vdash \fguard{t_2} \hyp{2} \]
	We get immediately the values \(t_2\), \(\nu\) and the hypothesis:
	\[ \sigma \uplus \nu \vdash \fguard{t_2} \hyp{2'} \]
	\(R\) satisfies (\ref{eq:WD}) with the current value of \(\mpar{s_1, s_2}\) and \(\sigma \uplus \nu\) completed with dummy values for the other variables of \(\bigcup_{t_2 \in \fOT{s_2}} \fguard{t_2}\) so we have:
	\[ \sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1} \hyp{3} \]
	The \(\vdash\) hides an implicit \(\exists\) that we use to get values to the variables in \(\bigcup_{t_1 \in \fOT{s_1}}\) in a valuation \(\mu\).
	The left side of the implication is proved using \hyp{1} and \hyp{2'} for the branch \(t_2\) of the disjunction.
	We are now allowed to decompose the right side to get \(t_1\) such that:
	\[ \sigma \uplus \nu \uplus \mu \vdash \fguard{t_1} \hyp{3'} \]
	At this point we have a \(t_1\) and a \(t_2\) so we may think that the proof is about to be finished because the only property left to prove is:
	\begin{multline}
		\bigsymb{\exists} \OTx{2}{}{2}{2} \in \fOT{s_2}, \OTx{1}{}{1}{1} \in \fOT{s_1}, \\
		\sigma \vdash g_2 \wedge \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge g_1 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2} \goal{1}
	\end{multline}
	However we cannot yet prove it because we don't know whether \(t_2\) and \(t_1\) do match.
	In order to get a \(t_2\) matching \(t_1\) we use will use \hyp{0}.
	\hyp{0} with current value of \(\mpar{s_1, s_2}\), \(t_1\) and \(\sigma \uplus \mu\) as a valuation of \(V_1 \uplus V_2 \uplus \fvars{t_1}\) gives:
	\begin{multline}
		\mpar{\sigma \uplus \mu \vdash R\mpar{s_1, s_2} \wedge g_1} \implies \exists t_2 \defobject \OTx{2}{}{2}{} \in \fOT{s_2}, \exists \nu: \fvars{t_2} \to \values, \\
		\sigma \uplus \mu \uplus \nu \vdash \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge g_2 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2} \hyp{0'}
	\end{multline}
	The left part of the implication is \hyp{1} and \hyp{3'}, so we get \(t'_2 \in \fOT{s_2}\), \(\nu': \fvars{t_2} \to \values\) and:
	\[ \sigma \uplus \mu \uplus \nu' \vdash \alpha_1 = \alpha'_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J''_2} \beta_{1j} = \beta'_{2j} \wedge g'_2 \wedge R\mpar{s'_1, s''_2}\psubst{\psi_1 \uplus \psi'_2} \hyp{target} \]
	The witnesses for \goal{1} are \(t'_2\) and \(t_1\), and the rest is proved with a combination of \hyp{target} and \hyp{3'}.
\item[\bf(\ref{eq:WD})\(\impliedby\)(\ref{eq:ID}):] % TODO: proof debt, restart here
	If \(R\) satisfies the equivalent formula, let \(\mpar{s_1, s_2} \in S_1 \times S_2\) and \(\sigma: V_1 \uplus V_2 \to \values\).
	The free variables of the equivalent formula are all in \(V_1 \uplus V_2\) so let \(\sigma: V_1 \uplus V_2 \to \values\) be such that
	\[ \sigma \vdash R\mpar{s_1, s_2} \wedge \bigvee_\subbox{t_2 \in \fOT{s_2}} \fguard{t_2} \implies \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1} \]
	We can decompose it by admitting the left part of the implication then decomposing the big disjunction to get \(\sigma \vdash R\mpar{s_1, s_2}\) as \hyp{p} and \(t_2 \in \fOT{s_2}\) such that \hyp{g2}: \(\sigma \vdash \fguard{t_2}\).
	We are left to prove \[ \sigma \vdash \bigvee_\subbox{t_1 \in \fOT{s_1}} \fguard{t_1} \goal{G1} \]
	To do that we will use the fact that \(R\) satisfies the deadlock reduction definition with the current value of \(s_1, s_2, \sigma\).
	Now we additionally need to prove \goal{G2}: \(\exists t_2 \in \fOT{s_2}, \sigma \vdash R\mpar{s_1, s_2} \wedge \fguard{t_2}\) before getting hypothesis \hyp{E}:
	\[ \bigsymb{\exists} \OTx{2}{}{2}{2} \in T_2, \OTx{1}{}{1}{1} \in T_1, \sigma \vdash g_2 \wedge \alpha_1 = \alpha_2 \wedge \bigwedge_\subbox{j \in J'_1 \cap J'_2} \beta_{1j} = \beta_{2j} \wedge g_1 \wedge R\mpar{s'_1, s'_2}\psubst{\psi_1 \uplus \psi_2} \]
	The witness of \goal{G2} is \(t_2\) obtained previously in the big disjunction, and \(\sigma \vdash R\mpar{s_1, s_2} \wedge \fguard{t_2}\) is proved by combining \hyp{p} and \hyp{g2}.
	Now we can decompose \hyp{E} to get \(t_1 \in T_1\), which we know is also in \(\fOT{s_1}\), a transition that we won't use and \(\sigma \vdash \fguard{t_1}\) which is what we needed to prove the branch \(t_1\) of \goal{G1}.
\end{proof}

% TODO

\end{document}
